import { db } from "@db";
import { emailOtps } from "@shared/schema";
import * as bcrypt from "bcrypt";
import { eq, and, lt } from "drizzle-orm";
import transporter from "../config/mail";

/**
 * Service for handling OTP (One-Time Password) operations
 */
class OtpService {
    /**
     * Generate a random 6-digit OTP code
     */
    generateOtp(): string {
        // Generate a 6-digit random number
        return Math.floor(100000 + Math.random() * 900000).toString();
    }

    /**
     * Save OTP to database
     * @param email The email to associate with the OTP
     * @param otp The plain text OTP
     * @returns The saved OTP record
     */
    async saveOtp(email: string, otp: string) {
        try {
            // Hash the OTP for security before storing in the database
            const hashedOtp = await bcrypt.hash(otp, 10);

            // Set expiration time (5 minutes from now)
            const expiresAt = new Date();
            expiresAt.setMinutes(expiresAt.getMinutes() + 5);

            // First invalidate any existing OTPs for this email
            await db
                .update(emailOtps)
                .set({ used: true })
                .where(eq(emailOtps.email, email));

            // Now save the new OTP
            const [savedOtp] = await db
                .insert(emailOtps)
                .values({
                    email,
                    otp: hashedOtp,
                    expires_at: expiresAt,
                    created_at: new Date(),
                })
                .returning();

            return savedOtp;
        } catch (error) {
            console.error("Error saving OTP:", error);
            throw new Error("Failed to save OTP");
        }
    }

    /**
     * Send OTP email to the user
     * @param email Recipient email
     * @param otp The OTP code to send
     */
    async sendOtpEmail(email: string, otp: string) {
        try {
            console.log(`ƒêang chu·∫©n b·ªã g·ª≠i m√£ OTP ${otp} t·ªõi ƒë·ªãa ch·ªâ ${email}...`);
            
            // Email template
            const mailOptions = {
                from: process.env.MAIL_FROM || "HomiTutor <noreply@homitutor.vn>",
                to: email,
                subject: "M√£ x√°c th·ª±c OTP - HomiTutor",
                html: this.getEmailTemplate(otp),
            };

            // Log OTP trong console v√† g·ª≠i email th·∫≠t
            console.log("\n=============================================");
            console.log("üìß Email: " + email);
            console.log("üîë M√É OTP: " + otp);
            console.log("üì§ G·ª≠i email th·∫≠t ƒë·∫øn ƒë·ªãa ch·ªâ tr√™n...");
            console.log("=============================================\n");
            
            console.log("ƒêang k·∫øt n·ªëi t·ªõi SMTP server...");
            // G·ª≠i email trong c·∫£ m√¥i tr∆∞·ªùng development v√† production
            const info = await transporter.sendMail(mailOptions);
            console.log("‚úÖ Email ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng!");
            
            // Log th√¥ng tin chi ti·∫øt v·ªÅ email
            console.log("üìß Email ƒë√£ g·ª≠i t·ªõi: %s", email);
            
            // Log th√¥ng tin message ID v√† response n·∫øu c√≥
            if (info.messageId) {
                console.log("Email message ID:", info.messageId);
            }
            
            if (info.preview) {
                console.log("Preview URL: %s", info.preview);
            } else if (info.response) {
                console.log("Email response: %s", info.response);
            }

            return info;
        } catch (error) {
            console.error("Error sending OTP email:", error);
            throw new Error("Failed to send OTP email");
        }
    }

    /**
     * Verify OTP code against stored value
     * @param email The email associated with the OTP
     * @param otp The OTP to verify
     * @returns True if verification successful, false otherwise
     */
    async verifyOtp(email: string, otp: string): Promise<boolean> {
        try {
            // Get the latest unused OTP for this email
            const storedOtp = await db.query.emailOtps.findFirst({
                where: and(
                    eq(emailOtps.email, email),
                    eq(emailOtps.used, false)
                ),
                orderBy: (otps) => [otps.created_at],
            });

            if (!storedOtp) {
                console.log('No valid OTP found for email:', email);
                return false;
            }

            // Check if OTP has expired
            const now = new Date();
            const expiresAt = new Date(storedOtp.expires_at);

            if (now > expiresAt) {
                console.log('OTP expired. Current time:', now, 'Expires at:', expiresAt);
                return false;
            }

            // Verify OTP
            const isValid = await bcrypt.compare(otp, storedOtp.otp);
            console.log('OTP validation result:', isValid);

            if (isValid) {
                // Mark OTP as used
                await db
                    .update(emailOtps)
                    .set({ used: true })
                    .where(eq(emailOtps.id, storedOtp.id));
            }

            return isValid;
        } catch (error) {
            console.error("Error verifying OTP:", error);
            throw new Error("Failed to verify OTP");
        }
    }

    /**
     * Create HTML email template for OTP
     * @param otp The OTP code to include in the template
     * @returns HTML template string
     */
    private getEmailTemplate(otp: string): string {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #e0e0e0; border-radius: 5px;">
        <div style="text-align: center; margin-bottom: 20px;">
          <h1 style="color: #2563eb; margin: 0;">Homi<span style="color: #10b981;">Tutor</span></h1>
        </div>
        <div style="background-color: #f9fafb; padding: 20px; border-radius: 5px; margin-bottom: 20px;">
          <h2 style="margin-top: 0; color: #374151;">X√°c th·ª±c email c·ªßa b·∫°n</h2>
          <p style="color: #6b7280; margin-bottom: 20px;">Vui l√≤ng s·ª≠ d·ª•ng m√£ x√°c th·ª±c b√™n d∆∞·ªõi ƒë·ªÉ ho√†n t·∫•t qu√° tr√¨nh x√°c th·ª±c:</p>
          <div style="background-color: #ffffff; padding: 15px; border: 1px dashed #d1d5db; border-radius: 5px; text-align: center; margin-bottom: 20px;">
            <span style="font-size: 24px; font-weight: bold; letter-spacing: 5px; color: #2563eb;">${otp}</span>
          </div>
          <p style="color: #6b7280; margin-bottom: 0;">M√£ x√°c th·ª±c c√≥ hi·ªáu l·ª±c trong <strong>5 ph√∫t</strong>.</p>
          <p style="color: #6b7280; margin-top: 20px;">N·∫øu b·∫°n kh√¥ng y√™u c·∫ßu m√£ n√†y, vui l√≤ng b·ªè qua email n√†y.</p>
        </div>
        <div style="text-align: center; color: #9ca3af; font-size: 12px;">
          <p>¬© ${new Date().getFullYear()} HomiTutor. T·∫•t c·∫£ c√°c quy·ªÅn ƒë∆∞·ª£c b·∫£o l∆∞u.</p>
        </div>
      </div>
    `;
    }

    /**
     * Generate and send OTP in one function
     * @param email Recipient email
     * @returns The generated OTP
     */
    async generateAndSendOtp(email: string): Promise<string> {
        try {
            const otp = this.generateOtp();
            await this.saveOtp(email, otp);
            await this.sendOtpEmail(email, otp);
            return otp;
        } catch (error) {
            console.error("Error in generateAndSendOtp:", error);
            throw new Error("Failed to generate and send OTP");
        }
    }
}

export default new OtpService();
